# adds the $2 param to the beginning of the $1 variable
function addToVarBeg {
    export $1="${2}${!1}"
}


# adds the $2 param to the end of the $1 variable
function addToVarEnd {
    export $1="${!1}${2}"
}


# Check if PATH contains given data already.
# $1: content which is checked against PATH variable.
# $2: Alternative PATH like variable to work on, default is the "PATH"
function check_if_already_in_path {
    local _path_var="PATH"
    [ -n "${2}" ] && _path_var="${2}"

    if ! $(\grep -qE ":?${1}(:|$)" <(echo "${!_path_var}")); then
        return 1 # was not
    fi
    return 0 # was
}

# adds the $1 param to the beginning of PATH variable
# $1:
# $2: Alternative PATH like variable to work on, default is the "PATH"
function addToPathBeg {
    if ! check_if_already_in_path ${1} ${2}; then
        local _path_var="PATH"
        [ -n "${2}" ] && _path_var="${2}"
        addToVarBeg ${_path_var} "$1:"
    fi
}


# adds the $1 param to the end of PATH variable
# $1:
# $2: Alternative PATH like variable to work on, default is the "PATH"
function addToPathEnd {
    if ! check_if_already_in_path ${1} ${2}; then
        local _path_var="PATH"
        [ -n "${2}" ] && _path_var="${2}"
        addToVarEnd ${_path_var} ":$1"
    fi
}
alias addToPath='addToPathEnd'


#http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_11_02.html
# adds to path front or after to PATH, maybe better check how differs
#pathmunge () {
#    if ! echo $PATH | /bin/egrep -q "(^|:)$1($|:)" ; then
#        if [ "$2" = "after" ] ; then
#            PATH=$PATH:$1
#        else
#            PATH=$1:$PATH
#        fi
#    fi
#}


# replace in path or add if replace pattern not found in path
# $1    new path
# $2    old path in extended filename extension (extglob) syntax
# for example replace any user bin directory with "/home/user/bin":
# replaceAddInPath '/home/user/bin' '/home/+([[:alpha:]])/bin'
# above example needs extglob shell option to be set
function replaceAddInPath {
    export PATH=${PATH/$2/$1}
    # if didn't exist (no replacement done) add, and only add if something was
    # given
    [[ "${1}" ]] && addToPathEnd "$1"
}


function check_if_symlink_valid {
    # if is symlink and not readable
    if [[ -h "${1}" && ! -r "${1}" ]]; then
        return 0
    else
        return 1
    fi
}


function remove_symlink_if_bad {
    check_if_symlink_valid "${1}"
    if [ "$?" -eq 0 ]; then
        rm -iv "${1}"
    fi
}


# TODO: make 3 param version that 3th param holds the variable where result is
# stored
# $1 name of the parameter that holds the file to be checked, resulting
# absolut dir is stored to the same variable
# $2 absolut base path, default current working dir
function change_to_absolut_dir {
    shopt -s extglob
    if [ "${!1:0:1}x" == "/x" ]; then
        # already absolut dir
        return;
    fi
    local ___l_rmz="${2:-$(pwd)}/${!1}"
    # clean ".." from ___l_rmz, requires extglob
    while [ "${___l_rmz/\/..\/}" != "${___l_rmz}" ]; do
        ___l_rmz=${___l_rmz//\/+([^\/])\/..\//\/};
    done
    # clean trailing "/dir/.."
    ___l_rmz=${___l_rmz/%\/+([^\/])\/../}
    eval "${1}"="\${___l_rmz}"
}


function awhich {
    (alias; declare -f) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot $@
}


# $1: required program to be found with awhich.
function requires {
    awhich "${1}" &>/dev/null || \
        {
            echo "Error: \"${1}\" callable required (not found with awhich)." 1>&2
            exit 1
        }
}


# $1: parameter name which other string parameters ar stored
# $2..N: String parameters which are concatenated to ${!1}
function Join {
    local ___ft="${1}"
    shift
    eval "${___ft}"="\${!___ft}\${@}"
}


# simple msg function to use with color printing
# $1: "-n" optional parameter indicating not to print a newline.
# $1: color code
# $2..N: message to be printed
function Cmsg() {
    [[ "${1}" == "-n" ]] && { local no_newline='yes'; shift; }
    # 16 colors on black

    # hilight colors on black
    local WHITE_H="\033[1;37;40m"
    local CYAN_H="\033[1;36;40m"
    local PURPLE_H="\033[1;35;40m"
    local BLUE_H="\033[1;34;40m"
    local YELLOW_H="\033[1;33;40m"
    local GREEN_H="\033[1;32;40m"
    local RED_H="\033[1;31;40m"
    local BLACK_H="\033[1;30;40m"

    # colors on black
    local WHITE="\033[37;40m"
    local CYAN="\033[36;40m"
    local PURPLE="\033[35;40m"
    local BLUE="\033[34;40m"
    local YELLOW="\033[33;40m"
    local GREEN="\033[32;40m"
    local RED="\033[31;40m"
    local BLACK="\033[30;40m"

    # clear colors
    local CLR_COLOR="\033[1;0m"

    printf "${!1}${@:2}${CLR_COLOR}"
    [[ "${no_newline}" == 'yes' ]] || printf "\n"
}


# Cmsg() wrapper which prints to stderr
function Cemsg() {
    Cmsg $@ 1>&2
}


# simple function to just echo every parameter to stderr
# $1..N: These parameters are echoed to stderr.
function Eecho() {
    echo $@ 1>&2
}


# Gets current scripts path when given "${BASH_SOURCE[0]}" as parameter
# $1: "${BASH_SOURCE[0]}"
# $2: parameter name where script path is to be stored
function Get_script_path() {
    [[ "${1}" && "${2}" ]] || { Eecho "ERROR: Get_script_path needs two parameters."; return 1; }

    # get script path
    local script_path="${1}";

    # unlink path
    if [ -h "${script_path}" ]; then
        while [ -h "${script_path}" ]; do script_path=`readlink "${script_path}"`; done
    fi

    pushd . > /dev/null
    cd "$(dirname "${script_path}")" > /dev/null
    script_path="$(pwd)";
    popd  > /dev/null

    eval "${2}"="\${script_path}"
}

# Find files matching given regex (egrep style) from the given dir.
#
# Stores results to an array varible which name is given as a parameter.
# If given array name is "-" print found files to stdout.
#
# Options:
#   $1: -mp: match whole path not only basename
#   $1: -maxd: max search depth (default 1)
#   $1: -mind: min search depth (default 0)
#
# Positional:
#   $1: search dir
#   $2: regex
#   $3: array name where find archive file names are to be stored
Find_files() {
    #local -a CMDLINE_OPTIONS=(\
    #"-h|--help" \
    #"Print this help info." \
    #"{ display_help; exit; }" \

    #"-o|--option" \
    #"Example option." \
    #"{ VARIABLE='yes'; shift; }" \
    #)

    # TODO: read opts with while loop

    # TODO: implement min and max depth
    local match_path="false"
    [[ ${1} == "-mp" ]] && { match_path="true"; shift; }

    [[ "${1}" ]] || { echo "Find_archives(): Error: Search dir must be given."; return 1; }
    [[ "${2}" ]] || { echo "Find_archives(): Error: Regex must be given."; return 1; }
    [[ "${3}" ]] || { echo "find_archives(): Error: Array name must be given."; return 1; }

    local search_dir="${1}"
    if [[ $match_path == "false" ]]; then
        local regex="*./${2}"
    else
        local regex="${2}"
    fi
    local array_name="${3}"

    if [[ $array_name == "-" ]]; then
        find "${search_dir}" -maxdepth 1 -regextype posix-egrep -iregex "${regex}"
    else
        readarray -t "${array_name}" < \
            <(find "${search_dir}" -maxdepth 1 -regextype posix-egrep -iregex "${regex}")
    fi
}

# $1: file name to be sourced if it exists
Source_if_exists() {
    [[ -e ${1} ]] && source "${1}"
}
