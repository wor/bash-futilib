# adds the $2 param to the beginning of the $1 variable
function addToVarBeg {
    export $1="${2}${!1}"
}


# adds the $2 param to the end of the $1 variable
function addToVarEnd {
    export $1="${!1}${2}"
}


# Check if PATH contains given data already.
# $1: content which is checked against PATH variable.
# $2: Alternative PATH like variable to work on, default is the "PATH"
function check_if_already_in_path {
    local _path_var="PATH"
    [ -n "${2}" ] && _path_var="${2}"

    if ! $(\grep -qE ":?${1}(:|$)" <(echo "${!_path_var}")); then
        return 1 # was not
    fi
    return 0 # was
}

# adds the $1 param to the beginning of PATH variable
# $1:
# $2: Alternative PATH like variable to work on, default is the "PATH"
function addToPathBeg {
    if ! check_if_already_in_path ${1} ${2}; then
        local _path_var="PATH"
        [ -n "${2}" ] && _path_var="${2}"
        addToVarBeg ${_path_var} "$1:"
    fi
}


# adds the $1 param to the end of PATH variable
# $1:
# $2: Alternative PATH like variable to work on, default is the "PATH"
function addToPathEnd {
    if ! check_if_already_in_path ${1} ${2}; then
        local _path_var="PATH"
        [ -n "${2}" ] && _path_var="${2}"
        addToVarEnd ${_path_var} ":$1"
    fi
}
alias addToPath='addToPathEnd'


#http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_11_02.html
# adds to path front or after to PATH, maybe better check how differs
#pathmunge () {
#    if ! echo $PATH | /bin/egrep -q "(^|:)$1($|:)" ; then
#        if [ "$2" = "after" ] ; then
#            PATH=$PATH:$1
#        else
#            PATH=$1:$PATH
#        fi
#    fi
#}


# replace in path or add if replace pattern not found in path
# $1    new path
# $2    old path in extended filename extension (extglob) syntax
# for example replace any user bin directory with "/home/user/bin":
# replaceAddInPath '/home/user/bin' '/home/+([[:alpha:]])/bin'
# above example needs extglob shell option to be set
function replaceAddInPath {
    export PATH=${PATH/$2/$1}
    # if didn't exist (no replacement done) add, and only add if something was
    # given
    [[ "${1}" ]] && addToPathEnd "$1"
}


function check_if_symlink_valid {
    # if is symlink and not readable
    if [[ -h "${1}" && ! -r "${1}" ]]; then
        return 0
    else
        return 1
    fi
}


function remove_symlink_if_bad {
    check_if_symlink_valid "${1}"
    if [ "$?" -eq 0 ]; then
        rm -iv "${1}"
    fi
}


# TODO: make 3 param version that 3th param holds the variable where result is
# stored
# $1 name of the parameter that holds the file to be checked, resulting
# absolut dir is stored to the same variable
# $2 absolut base path, default current working dir
function change_to_absolut_dir {
    shopt -s extglob
    if [ "${!1:0:1}x" == "/x" ]; then
        # already absolut dir
        return;
    fi
    local ___l_rmz="${2:-$(pwd)}/${!1}"
    # clean ".." from ___l_rmz, requires extglob
    while [ "${___l_rmz/\/..\/}" != "${___l_rmz}" ]; do
        ___l_rmz=${___l_rmz//\/+([^\/])\/..\//\/};
    done
    # clean trailing "/dir/.."
    ___l_rmz=${___l_rmz/%\/+([^\/])\/../}
    eval "${1}"="\${___l_rmz}"
}


function awhich {
    (alias; declare -f) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot $@
}


# $1: required program to be found with awhich.
function requires {
    awhich "${1}" &>/dev/null || \
        {
            echo "Error: \"${1}\" callable required (not found with awhich)." 1>&2
            exit 1
        }
}


# $1: parameter name which other string parameters ar stored
# $2..N: String parameters which are concatenated to ${!1}
function Join {
    local ___ft="${1}"
    shift
    eval "${___ft}"="\${!___ft}\${@}"
}


# simple msg function to use with color printing
# $1: color code
# $2..N: message to be printed
function Cmsg() {
    # 16 colors on black

    # hilight colors on black
    local WHITE_H="\033[1;37;40m"
    local CYAN_H="\033[1;36;40m"
    local PURPLE_H="\033[1;35;40m"
    local BLUE_H="\033[1;34;40m"
    local YELLOW_H="\033[1;33;40m"
    local GREEN_H="\033[1;32;40m"
    local RED_H="\033[1;31;40m"
    local BLACK_H="\033[1;30;40m"

    # colors on black
    local WHITE="\033[37;40m"
    local CYAN="\033[36;40m"
    local PURPLE="\033[35;40m"
    local BLUE="\033[34;40m"
    local YELLOW="\033[33;40m"
    local GREEN="\033[32;40m"
    local RED="\033[31;40m"
    local BLACK="\033[30;40m"

    # clear colors
    local CLR_COLOR="\033[1;0m"

    printf "${!1}${@:2}${CLR_COLOR}\n"
}
