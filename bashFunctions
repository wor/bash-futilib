# adds the $2 param to the beginning of the $1 variable
function addToVarBeg {
    export $1="${2}${!1}"
}


# adds the $2 param to the end of the $1 variable
function addToVarEnd {
    export $1="${!1}${2}"
}


# adds the $1 param to the end of PATH variable
function addToPath {
    if ! $(\grep -qE ":?${1}(:|$)" <(echo "${PATH}")); then
        addToVarEnd PATH ":$1" 
    fi  
}


# replace in path or add replace pattern not found in path
# $1    new path
# $2    old path in extended filename extension (extglob) syntax
# for example replace any user bin directory with "/home/user/bin":
# replaceAddInPath '/home/user/bin' '/home/+([[:alpha:]])/bin'
# above example needs extglob shell option to be set
function replaceAddInPath {
    export PATH=${PATH/$2/$1}
    # if didn't exist (no replacement done) add
    addToPath "$1"
}


function check_if_symlink_valid {
    # if is symlink and not readable
    if [[ -h "${1}" && ! -r "${1}" ]]; then 
        return 0
    else
        return 1
    fi
}


function remove_symlink_if_bad {
    check_if_symlink_valid "${1}"
    if [ "$?" -eq 0 ]; then
        rm -iv "${1}"
    fi 
}


# TODO: make 3 param version that 3th param holds the variable where result is
# stored
# $1 name of the parameter that holds the file to be checked, resulting
# absolut dir is stored to the same variable
# $2 absolut base path, default current working dir
function change_to_absolut_dir {
    if [ "${!1:0:1}x" == "/x" ]; then 
        # already absolut dir
        return;
    fi
    local base_dir="${2}"
    base_dir=${base_dir:-$(pwd)}
    eval "${1}"="\${base_dir}/\${!1}"
}

function awhich {
    (alias; declare -f) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot $@
}
