# vim: ft=sh

# adds the $2 param to the beginning of the $1 variable
addToVarBeg() {
    export $1="${2}${!1}"
}


# adds the $2 param to the end of the $1 variable
addToVarEnd() {
    export $1="${!1}${2}"
}


# Check if PATH contains given data already.
# $1: content which is checked against PATH variable.
# $2: Alternative PATH like variable to work on, default is the "PATH"
check_if_already_in_path() {
    local _path_var="PATH"
    [ -n "${2}" ] && _path_var="${2}"

    if ! $(\grep -qE ":?${1}(:|$)" <(echo "${!_path_var}")); then
        return 1 # was not
    fi
    return 0 # was
}

# adds the $1 param to the beginning of PATH variable
# $1:
# $2: Alternative PATH like variable to work on, default is the "PATH"
addToPathBeg() {
    if ! check_if_already_in_path ${1} ${2}; then
        local _path_var="PATH"
        [ -n "${2}" ] && _path_var="${2}"
        addToVarBeg ${_path_var} "$1:"
    fi
}


# adds the $1 param to the end of PATH variable
# $1:
# $2: Alternative PATH like variable to work on, default is the "PATH"
addToPathEnd() {
    if ! check_if_already_in_path ${1} ${2}; then
        local _path_var="PATH"
        [ -n "${2}" ] && _path_var="${2}"
        addToVarEnd ${_path_var} ":$1"
    fi
}
alias addToPath='addToPathEnd'


#http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_11_02.html
# adds to path front or after to PATH, maybe better check how differs
#pathmunge () {
#    if ! echo $PATH | /bin/egrep -q "(^|:)$1($|:)" ; then
#        if [ "$2" = "after" ] ; then
#            PATH=$PATH:$1
#        else
#            PATH=$1:$PATH
#        fi
#    fi
#}


# replace in path or add if replace pattern not found in path
# $1    new path
# $2    old path in extended filename extension (extglob) syntax
# for example replace any user bin directory with "/home/user/bin":
# replaceAddInPath '/home/user/bin' '/home/+([[:alpha:]])/bin'
# above example needs extglob shell option to be set
replaceAddInPath() {
    export PATH=${PATH/$2/$1}
    # if didn't exist (no replacement done) add, and only add if something was
    # given
    [[ "${1}" ]] && addToPathEnd "$1"
}


check_if_symlink_valid() {
    # if is symlink and not readable
    if [[ -h "${1}" && ! -r "${1}" ]]; then
        return 0
    else
        return 1
    fi
}


remove_symlink_if_bad() {
    check_if_symlink_valid "${1}"
    if [ "$?" -eq 0 ]; then
        rm -iv "${1}"
    fi
}


# TODO: make 3 param version that 3th param holds the variable where result is
# stored
# $1 name of the parameter that holds the file to be checked, resulting
# absolut dir is stored to the same variable
# $2 absolut base path, default current working dir
change_to_absolut_dir() {
    shopt -s extglob
    if [ "${!1:0:1}x" == "/x" ]; then
        # already absolut dir
        return;
    fi
    local ___l_rmz="${2:-$(pwd)}/${!1}"
    # clean ".." from ___l_rmz, requires extglob
    while [ "${___l_rmz/\/..\/}" != "${___l_rmz}" ]; do
        ___l_rmz=${___l_rmz//\/+([^\/])\/..\//\/};
    done
    # clean trailing "/dir/.."
    ___l_rmz=${___l_rmz/%\/+([^\/])\/../}
    eval "${1}"="\${___l_rmz}"
}


awhich() {
    (alias; declare -f) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot $@
}


# $1: required program to be found with awhich.
requires() {
    awhich "${1}" &>/dev/null || \
        {
            echo "Error: \"${1}\" callable required (not found with awhich)." 1>&2
            exit 1
        }
}


# $1: parameter name which other string parameters ar stored
# $2..N: String parameters which are concatenated to ${!1}
Join() {
    local ___ft="${1}"
    shift
    eval "${___ft}"="\${!___ft}\${@}"
}


# simple msg function to use with color printing
# $1: "-n" optional parameter indicating not to print a newline.
# $1: color code
# $2..N: message to be printed
Cmsg() {
    [[ "${1}" == "-n" ]] && { local no_newline='yes'; shift; }
    # 16 colors on black

    # hilight colors on black
    local WHITE_H="\033[1;37;40m"
    local CYAN_H="\033[1;36;40m"
    local PURPLE_H="\033[1;35;40m"
    local BLUE_H="\033[1;34;40m"
    local YELLOW_H="\033[1;33;40m"
    local GREEN_H="\033[1;32;40m"
    local RED_H="\033[1;31;40m"
    local BLACK_H="\033[1;30;40m"

    # colors on black
    local WHITE="\033[37;40m"
    local CYAN="\033[36;40m"
    local PURPLE="\033[35;40m"
    local BLUE="\033[34;40m"
    local YELLOW="\033[33;40m"
    local GREEN="\033[32;40m"
    local RED="\033[31;40m"
    local BLACK="\033[30;40m"

    # clear colors
    local CLR_COLOR="\033[1;0m"

    printf "${!1}${@:2}${CLR_COLOR}"
    [[ "${no_newline}" == 'yes' ]] || printf "\n"
}


# Cmsg() wrapper which prints to stderr
Cemsg() {
    Cmsg $@ 1>&2
}


# simple function to just echo every parameter to stderr
# $1..N: These parameters are echoed to stderr.
Eecho() {
    echo $@ 1>&2
}


# Gets current scripts path when given "${BASH_SOURCE[0]}" as parameter
# $1: "${BASH_SOURCE[0]}"
# $2: parameter name where script path is to be stored
Get_script_path() {
    [[ "${1}" && "${2}" ]] || { Eecho "ERROR: Get_script_path needs two parameters."; return 1; }

    # get script path
    local script_path="${1}";

    # unlink path
    if [ -h "${script_path}" ]; then
        while [ -h "${script_path}" ]; do script_path=`readlink "${script_path}"`; done
    fi

    pushd . > /dev/null
    cd "$(dirname "${script_path}")" > /dev/null
    script_path="$(pwd)";
    popd  > /dev/null

    eval "${2}"="\${script_path}"
}

# Find files matching given regex (egrep style) from the given dir.
#
# Stores results to an array varible which name is given as a parameter.
# If given array name is "-" print found files to stdout.
#
# Options:
#   $1: -mp: match whole path not only basename
#   $1: -maxd: max search depth (default 1)
#   $1: -mind: min search depth (default 0)
#
# Positional:
#   $1: search dir
#   $2: regex
#   $3: array name where find archive file names are to be stored
Find_files() {
    #local -a CMDLINE_OPTIONS=(\
    #"-h|--help" \
    #"Print this help info." \
    #"{ display_help; exit; }" \

    #"-o|--option" \
    #"Example option." \
    #"{ VARIABLE='yes'; shift; }" \
    #)

    # TODO: read opts with while loop

    # TODO: implement min and max depth
    local match_path="false"
    [[ ${1} == "-mp" ]] && { match_path="true"; shift; }

    [[ "${1}" ]] || { echo "Find_archives(): Error: Search dir must be given."; return 1; }
    [[ "${2}" ]] || { echo "Find_archives(): Error: Regex must be given."; return 1; }
    [[ "${3}" ]] || { echo "find_archives(): Error: Array name must be given."; return 1; }

    local search_dir="${1}"
    if [[ $match_path == "false" ]]; then
        # TODO: is there way with find to match just the basename not the whole path
        #       because this is not a complete fix, for example '^' doesn't work in given regex
        local regex=".*/${2}"
    else
        local regex="${2}"
    fi
    local array_name="${3}"

    if [[ $array_name == "-" ]]; then
        find "${search_dir}" -maxdepth 1 -regextype posix-egrep -iregex "${regex}"
    else
        readarray -t "${array_name}" < \
            <(find "${search_dir}" -maxdepth 1 -regextype posix-egrep -iregex "${regex}")
    fi
}

# $1: file name to be sourced if it exists
Source_if_exists() {
    [[ -e ${1} ]] && source "${1}"
}

# $1: array variable name
Print_array() {
    # TODO: is there other way to access array by it's variable name?
    eval temp_array=(\${${1}[@]\})
    i=0
    for v in "${temp_array[@]}"; do
        echo "$i: $v"
        ((++i))
    done
}

### Structure of the CMDLINE_OPTIONS:
# CMDLINE_OPTIONS is an array of strings where the number of strings is mod 3 (0,3,6,9...).
#
### Semantics of the CMDLINE_OPTIONS:
# Every option consists of three strings in the array.
# 1. String is the switch/case pattern
# 2. String is help or description for the option.
# 3. String is bash code to be evaluated when the option is parsed.
#    At the moment it should contain "shift" statement to proceed to the next option.
#
### Example of CMDLINE_OPTIONS with three options:
# local -a CMDLINE_OPTIONS=(\
# "-h|--help" \
# "Print this help info." \
# "{ Display_help; exit; }" \
#
# "-o|--option" \
# "Example option." \
# "{ VARIABLE='yes'; shift; }" \
#
# "-v|--verbose" \
# "Be more verbose." \
# "{ ((VERBOSITY_LEVEL++)); shift; }" \
# )
#
### Structure of the CMDLINE_ARGUMENTS:
# CMDLINE_ARGUMENTS is an array of strings where the number of strings is mod 2 (0,2,4,6...).
#
### Semantics of the CMDLINE_ARGUMENTS:
# Every option consists of two strings in the array.
# 1. String is the argument name and same time the variable name for the argument.
# 2. String is help or description for the option.
#
### Example of CMDLINE_ARGUMENTS with two arguments:
# local -a CMDLINE_ARGUMENTS=(\
#     'FILENAME_IN'
#     'Filename to be read.'
#
#     'FILENAME_OUT'
#     'Filename to be written.'
# )

# Displays help for command line program
# Uses variables:
#  array CMDLINE_ARGUMENTS
#  array CMDLINE_OPTIONS
Display_help() {
    echo "Usage: "
    local usage="\t$(basename ${0}) [options] "
    for ((i=0; i<${#CMDLINE_ARGUMENTS[@]}; i=i+2)); do
        usage="${usage}${CMDLINE_ARGUMENTS[i]} "
    done
    echo -e "${usage}"

    if [[ ${#CMDLINE_OPTIONS[@]} > 0 ]]; then
        echo
        echo "Options: "
        for ((i=0; i<${#CMDLINE_OPTIONS[@]}; i=i+3)); do
            printf "%-20s %s\n" "${CMDLINE_OPTIONS[i]}" "${CMDLINE_OPTIONS[i+1]}"
        done
    fi

    if [[ ${#CMDLINE_ARGUMENTS[@]} > 0 ]]; then
        echo
        echo "Arguments: "
        for ((i=0; i<${#CMDLINE_ARGUMENTS[@]}; i=i+2)); do
            printf "%-20s %s\n" "${CMDLINE_ARGUMENTS[i]}" "${CMDLINE_ARGUMENTS[i+1]}"
        done
    fi
}

# Parses command line options and arguments.
# Uses variables:
#  array CMDLINE_ARGUMENTS
#  array CMDLINE_OPTIONS
Process_cmdline() {
    # Generate cmdline option reading loop and execute it
    local run="
    while [[ \$1 = -* ]]; do
        case \"\$1\" in
        "
    for ((i=0; i<${#CMDLINE_OPTIONS[@]}; i=i+3)); do
        run="${run}${CMDLINE_OPTIONS[i]})
            ${CMDLINE_OPTIONS[i+2]}
            ;;
        "
    done
    run="${run}*)
            echo \"Error: Unknown option: \$1\" >&2;
            { display_help; return 1; }
            ;;
        esac
    done
    "
    eval ${run}

    # Generate argument checking
    if [[ 0 < ${#CMDLINE_ARGUMENTS[@]} ]]; then
        local run=''
        for ((i=0; i<${#CMDLINE_ARGUMENTS[@]}; i=i+2)); do
            run="${run}
            [[ \"\$1\" ]] ||
                { Eecho 'Error: No \"${CMDLINE_ARGUMENTS[i]}\" given.'; return 1; };
                    ${CMDLINE_ARGUMENTS[i]}=\"\$1\"; shift;
                    "
        done
        #echo "${run}"
        eval ${run}
    fi

    if [[ "$@" ]]; then
        Eecho "Error: Unkown argument(s) given: $@"
        return 1
    fi

    return 0
}
