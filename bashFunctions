# vim: ft=sh
#
# TODO: REFACTOR: "printf -v var" can be in some cases used to replace eval
# TODO: read:
#    http://fvue.nl/wiki/Bash:_passing_variables_by_reference
#    http://www.mail-archive.com/bug-bash@gnu.org/msg07352.html
#

# adds the $2 param to the beginning of the $1 variable
addToVarBeg() {
    export $1="${2}${!1}"
}


# adds the $2 param to the end of the $1 variable
addToVarEnd() {
    export $1="${!1}${2}"
}


# Check if PATH contains given data already.
# $1: content which is checked against PATH variable.
# $2: Alternative PATH like variable to work on, default is the "PATH"
check_if_already_in_path() {
    local _path_var="PATH"
    [ -n "${2}" ] && _path_var="${2}"

    if ! $(\grep -qE ":?${1}(:|$)" <(echo "${!_path_var}")); then
        return 1 # was not
    fi
    return 0 # was
}

# adds the $1 param to the beginning of PATH variable
# $1:
# $2: Alternative PATH like variable to work on, default is the "PATH"
addToPathBeg() {
    if ! check_if_already_in_path ${1} ${2}; then
        local _path_var="PATH"
        [ -n "${2}" ] && _path_var="${2}"
        if [[ "${!_path_var}" ]]; then
            addToVarBeg "${_path_var}" "${1}:"
        else
            # In case if path variable is empty
            printf -v "${_path_var}" "%s" "${1}"
        fi
    fi
}


# adds the $1 param to the end of PATH variable
# $1:
# $2: Alternative PATH like variable to work on, default is the "PATH"
addToPathEnd() {
    if ! check_if_already_in_path ${1} ${2}; then
        local _path_var="PATH"
        [ -n "${2}" ] && _path_var="${2}"
        if [[ "${!_path_var}" ]]; then
            addToVarEnd "${_path_var}" ":${1}"
        else
            # In case if path variable is empty
            printf -v "${_path_var}" "%s" "${1}"
        fi
    fi
}
alias addToPath='addToPathEnd'


#http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_11_02.html
# adds to path front or after to PATH, maybe better check how differs
#pathmunge () {
#    if ! echo $PATH | /bin/egrep -q "(^|:)$1($|:)" ; then
#        if [ "$2" = "after" ] ; then
#            PATH=$PATH:$1
#        else
#            PATH=$1:$PATH
#        fi
#    fi
#}


# replace in path or add if replace pattern not found in path
# $1    new path
# $2    old path in extended filename extension (extglob) syntax
# for example replace any user bin directory with "/home/user/bin":
# replaceAddInPath '/home/user/bin' '/home/+([[:alpha:]])/bin'
# above example needs extglob shell option to be set
replaceAddInPath() {
    export PATH=${PATH/$2/$1}
    # if didn't exist (no replacement done) add, and only add if something was
    # given
    [[ "${1}" ]] && addToPathEnd "$1"
}


check_if_symlink_valid() {
    # if is symlink and not readable
    if [[ -h "${1}" && ! -r "${1}" ]]; then
        return 0
    else
        return 1
    fi
}


remove_symlink_if_bad() {
    check_if_symlink_valid "${1}"
    if [ "$?" -eq 0 ]; then
        rm -iv "${1}"
    fi
}


# Checks if given path is absolute.
# $1: Variable name containing the path
Is_path_absolute() {
    if [[ "${!1:0:1}" == "/" ]]; then
        return 0
    fi
    return 1
}


# TODO: make 3 param version that 3th param holds the variable where result is
# stored
# $1 name of the parameter that holds the file to be checked, resulting
# absolut dir is stored to the same variable
# $2 absolut base path, default current working dir
change_to_absolut_dir() {
    shopt -s extglob
    # Check if already absolute path
    Is_path_absolute "${1}" && return

    local ___l_rmz="${2:-$(pwd)}/${!1}"
    # clean ".." from ___l_rmz, requires extglob
    while [ "${___l_rmz/\/..\/}" != "${___l_rmz}" ]; do
        ___l_rmz=${___l_rmz//\/+([^\/])\/..\//\/};
    done

    # clean trailing "/dir/.."
    ___l_rmz=${___l_rmz/%\/+([^\/])\/../}

    # Clean trailing ".", happens if given path is "." for example
    ___l_rmz=${___l_rmz/%\/.//}

    printf -v "${1}" "%s" "${___l_rmz}"
}


awhich() {
    (alias; declare -f) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot $@
}


# $1: required program to be found with awhich.
requires() {
    awhich "${1}" &>/dev/null || \
        {
            echo "Error: \"${1}\" callable required (not found with awhich)." 1>&2
            exit 1
        }
}

# $1: Variable name which is required to have value set.
Requires_var() {
    [[ -v "${1}" ]] || \
        {
            echo "Error: Variable \"${1}\" is needed." 1>$2
            exit 1
        }
}

# $1: parameter name which other string parameters ar stored
# $2..N: String parameters which are concatenated to ${!1}
Join() {
    local ___ft="${1}"
    shift
    eval "${___ft}"="\${!___ft}\${@}"
}


# simple msg function to use with color printing
# $1: "-n" optional parameter indicating not to print a newline.
# $1: color code
# $2..N: message to be printed
Cmsg() {
    [[ "${1}" == "-n" ]] && { local no_newline='yes'; shift; }
    # 16 colors on black

    # hilight colors on black
    local WHITE_H="\033[1;37;40m"
    local CYAN_H="\033[1;36;40m"
    local PURPLE_H="\033[1;35;40m"
    local BLUE_H="\033[1;34;40m"
    local YELLOW_H="\033[1;33;40m"
    local GREEN_H="\033[1;32;40m"
    local RED_H="\033[1;31;40m"
    local BLACK_H="\033[1;30;40m"

    # colors on black
    local WHITE="\033[37;40m"
    local CYAN="\033[36;40m"
    local PURPLE="\033[35;40m"
    local BLUE="\033[34;40m"
    local YELLOW="\033[33;40m"
    local GREEN="\033[32;40m"
    local RED="\033[31;40m"
    local BLACK="\033[30;40m"

    # clear colors
    local CLR_COLOR="\033[1;0m"

    printf "${!1}${@:2}${CLR_COLOR}"
    [[ "${no_newline}" == 'yes' ]] || printf "\n"
}


# Cmsg() wrapper which prints to stderr
Cemsg() {
    Cmsg $@ 1>&2
}


# simple function to just echo every parameter to stderr
# $1..N: These parameters are echoed to stderr.
Eecho() {
    echo $@ 1>&2
}


# Gets current scripts path when given "${BASH_SOURCE[0]}" as parameter
# $1: "${BASH_SOURCE[0]}"
# $2: parameter name where script path is to be stored
Get_script_path() {
    [[ "${1}" && "${2}" ]] || { Eecho "ERROR: Get_script_path needs two parameters."; return 1; }

    # get script path
    local script_path="${1}";

    # unlink path
    if [ -h "${script_path}" ]; then
        while [ -h "${script_path}" ]; do script_path=`readlink "${script_path}"`; done
    fi

    pushd . > /dev/null
    cd "$(dirname "${script_path}")" > /dev/null
    script_path="$(pwd)";
    popd  > /dev/null

    eval "${2}"="\${script_path}"
}

# Find files matching given regex (egrep style) from the given dir.
#
# Stores results to an array varible which name is given as a parameter.
# If given array name is "-" print found files to stdout.
#
# Options:
#   $1: -mp: match whole path not only basename
#   $1: -maxd: max search depth (default 1)
#   $1: -mind: min search depth (default 0)
#
# Positional:
#   $1: search dir
#   $2: regex
#   $3: array name where find archive file names are to be stored
Find_files() {
    #local -a CMDLINE_OPTIONS=(\
    #"-h|--help" \
    #"Print this help info." \
    #"{ display_help; exit; }" \

    #"-o|--option" \
    #"Example option." \
    #"{ VARIABLE='yes'; shift; }" \
    #)

    # TODO: read opts with while loop

    # TODO: implement min and max depth
    local match_path="false"
    [[ ${1} == "-mp" ]] && { match_path="true"; shift; }

    [[ "${1}" ]] || { echo "Find_archives(): Error: Search dir must be given."; return 1; }
    [[ "${2}" ]] || { echo "Find_archives(): Error: Regex must be given."; return 1; }
    [[ "${3}" ]] || { echo "find_archives(): Error: Array name must be given."; return 1; }

    local search_dir="${1}"
    if [[ $match_path == "false" ]]; then
        # TODO: is there way with find to match just the basename not the whole path
        #       because this is not a complete fix, for example '^' doesn't work in given regex
        local regex=".*/${2}"
    else
        local regex="${2}"
    fi
    local array_name="${3}"

    if [[ $array_name == "-" ]]; then
        find "${search_dir}" -maxdepth 1 -regextype posix-egrep -iregex "${regex}"
    else
        readarray -t "${array_name}" < \
            <(find "${search_dir}" -maxdepth 1 -regextype posix-egrep -iregex "${regex}")
    fi
}

# $1: file name to be sourced if it exists
Source_if_exists() {
    [[ -e ${1} ]] && source "${1}"
}

# $1: array variable name
Print_array() {
    # NOTE: another way to preserve spaces and access array by it's name (ugly as hell)
    #eval "for c in \"\${${1}[@]}\"; do temp_array+=(\"\${c}\"); done"

    # To get array variables indirectly: local vars="${1}[@]"; echo ${!vars}
    # How to get arrays keys indirectly without using eval

    local variables_i="${1}[\${i}]"
    eval 'local -a keys=(${!'${1}'[@]})' # XXX: How to do this without eval

    for i in "${keys[@]}"; do
        echo "$i: ${!variables_i}"
    done
}

# $1: array variable name
Sort_array() {
    local -a temp_array
    local temp="${1}[@]"
    temp_array+=("${!temp}")
    readarray -t "${1}" < \
        <(
            for v in "${temp_array[@]}"; do
                echo "${v}"
            done | sort
        )
}

# $1: array name
# $2: value to be appended to the array
Append_array() {
    local array_name="${1}"; shift
    local value_to_be_appended="${1}"; shift

    eval "${array_name}[\${#${array_name}[@]}]=\"${value_to_be_appended}\""
}


#Is_array() {
#    local var="${1}"
#
#    local pattern="^declare"
#
#    type=$(declare -p "${var}" 2>/dev/null)
#    if [[ ${type} =~ ${pattern}" -a" ]]; then
#        echo 1
#    fi
#}

# Clean this
#Array_copy() {
#    local source_a=$1; shift
#    local dest_a=$1; shift
#
#    #if [[ -n $(is_array $source) && -n $dest ]]; then
#    eval "$dest=(\"\${$var""[@]}\")"
#    #fi
#}

# Generates next non existing filename with given prefix.
#
# The prefix is the first name, and if it exists the next ones are names
# postfixed with ".<number>", where the number is from ordered range [0-19].
#
# The first parameter defines what happens when all the generated
# filenames in the range exists:
#
# TODO: add option for creating the generated filename with mktemp, or similar.
#       Question is how to use mktemp to generate sequential names.
#
# E: Produce error, and return nothing.
# L: Keep returing the last generated name.
# C: Cycle names always selecting name next to one, that has the most recent creation date.
#
# $1: Type # TODO, now "E" is the default
# $2: Variable name containing the prefix for the filename.
#     The result is stored to this variable if new filename generation succeeded.
Next_free_fn() {
    shopt -s extglob
    local prefix="${!2}"
    local max_count=3
    local count=0

    [[ -e ${prefix} ]] || return 0
    prefix="${prefix}.${count}" # Prepare first name

    while [[ -e ${prefix} && ${count} < ${max_count} ]]; do
        ((++count))
        prefix="${prefix/%.+([0-9])/}" # Remove added postfix
        prefix="${prefix}.${count}"    # and add a new one
    done

    if ((count >= ${max_count} )); then
        echo "Error: Last name of the filename range existed: ${prefix}."
        return 1
    fi

    eval ${2}=\""${prefix}"\"
    return 0
}

Petc() {
    echo "Press enter to continue.."
    read
}

# Returns total size of files/dirs in given array in bytes
# $1: array of file/dir names
# $2: variable where sum of given file/dir sizes is to be stored
Total_size() {
    local paths_n="${1}"; shift
    local total_size_n="${1}"; shift

    local paths="${paths_n}[\${path}]"
    eval 'local -a keys=(${!'${paths_n}'[@]})' # XXX: How to do this without eval

    local __bf__sum=0
    for path in "${keys[@]}"; do
        if [[ -d "${!paths}" ]]; then
            local temp_dir_size="$(du -b f)"
            temp_dir_size="${temp_dir_size%% *}"
            ((__bf__sum=__bf__sum+temp_dir_size))
        elif [[ -e "${!paths}" ]]; then
            local temp_file_size="$(stat -c%s "${!paths}")"
            ((__bf__sum=__bf__sum+temp_file_size))
        fi
    done

    # NOTE: printf is safer than eval, total_size_n can be anything..
    #eval "${total_size_n}=${__bf__sum}"
    printf -v "${total_size_n}" "%s" "${__bf__sum}"
}

# Returns tag (number) for current desktop
# $1: Variable name where current desktop tag is to be stored.
Get_current_desktop_tag() {
    local __BF__vn_current_tag="${1}"
    requires xdotool
    requires python
    local __BF__current_desktop="$(xdotool get_desktop)"
    printf -v "${__BF__vn_current_tag}" "%i" "$(python -c "import math; print(math.floor(math.log(${__BF__current_desktop},2)))")"
}

### Structure of the CMDLINE_OPTIONS:
# CMDLINE_OPTIONS is an array of strings where the number of strings is mod 3 (0,3,6,9...).
#
### Semantics of the CMDLINE_OPTIONS:
# Every option consists of three strings in the array.
# 1. String is the switch/case pattern
# 2. String is help or description for the option.
# 3. String is bash code to be evaluated when the option is parsed.
#    At the moment it should contain "shift" statement to proceed to the next option.
#
### Example of CMDLINE_OPTIONS with three options:
# local -a CMDLINE_OPTIONS=(\
# "-h|--help" \
# "Print this help info." \
# "{ Display_help; exit; }" \
#
# "-o|--option" \
# "Example option." \
# "{ VARIABLE='yes'; shift; }" \
#
# "-v|--verbose" \
# "Be more verbose." \
# "{ ((VERBOSITY_LEVEL++)); shift; }" \
# )
#
### Structure of the CMDLINE_ARGUMENTS:
# CMDLINE_ARGUMENTS is an array of strings where the number of strings is mod 3 (0,3,6,9..).
#
### Semantics of the CMDLINE_ARGUMENTS:
# Every option consists of three strings in the array.
# 1. String is the argument name and same time the variable name for the argument.
# 2. String is help or description for the option.
# 3. String is the option string, defined below.
#
### Option string:
# Heres definition of possible "options" content as regex.
# [0-9]+    : Number indicating count of arguments needed.
# \*        : Zero or more arguments needed.
# \+        : One or more arguments needed.
#
# Default option string is "1", meaning one argument needed.
#
### Example of CMDLINE_ARGUMENTS with two arguments:
# local -a CMDLINE_ARGUMENTS=(\
#     'FILENAME_IN'
#     'Filename to be read.'
#     '1'
#
#     'FILENAME_OUT'
#     'Filename to be written.'
#     ''    # same as 1, as 1 is the default.
# )

# Displays help for command line program
# Uses variables:
#  array CMDLINE_ARGUMENTS
#  array CMDLINE_OPTIONS
#  PROGRAM_DESCRIPTION
Display_help() {
    echo "Usage: "
    local usage="\t$(basename ${0}) [options] "
    for ((i=0; i<${#CMDLINE_ARGUMENTS[@]}; i=i+3)); do
        usage="${usage}${CMDLINE_ARGUMENTS[i]}"
        # Parse options string to usage
        local options="${CMDLINE_ARGUMENTS[i+2]}"
        if [[ "${options}" ]]; then
            if [[ "${options}" =~ ^[0-9]+$ ]]; then
                usage="${usage}{${options}}"
            else
                usage="${usage}${options}"
            fi
        fi
        usage="${usage} "
    done
    echo -e "${usage}"

    [[ "${PROGRAM_DESCRIPTION}" ]] && echo -e "\n${PROGRAM_DESCRIPTION}"

    # TODO: add automatic default parameter printing
    if [[ ${#CMDLINE_OPTIONS[@]} > 0 ]]; then
        echo
        echo "Options: "
        printf "%-20s %s\n" "-h|--help" "Print this help info."
        for ((i=0; i<${#CMDLINE_OPTIONS[@]}; i=i+3)); do
            printf "%-20s %s\n" "${CMDLINE_OPTIONS[i]}" "${CMDLINE_OPTIONS[i+1]}"
        done
    fi

    if [[ ${#CMDLINE_ARGUMENTS[@]} > 0 ]]; then
        echo
        echo "Arguments: "
        for ((i=0; i<${#CMDLINE_ARGUMENTS[@]}; i=i+3)); do
            printf "%-20s %s\n" "${CMDLINE_ARGUMENTS[i]}" "${CMDLINE_ARGUMENTS[i+1]}"
        done
    fi
}

# Parses command line options and arguments.
# Uses variables:
#  array CMDLINE_ARGUMENTS
#  array CMDLINE_OPTIONS
Process_cmdline() {
    # Generate cmdline option reading loop and execute it
    local run="
    while [[ \$1 = -?* ]]; do
        case \"\$1\" in
        -h|--help)
            { Display_help; exit; }
            ;;
        "
    for ((i=0; i<${#CMDLINE_OPTIONS[@]}; i=i+3)); do
        run="${run}${CMDLINE_OPTIONS[i]})
            ${CMDLINE_OPTIONS[i+2]}
            ;;
        "
    done
    run="${run}\*)
            echo \"Error: Unknown option: \$1\" >&2;
            { display_help; return 1; }
            ;;
        esac
    done
    "
    #echo "${run}" # For debug
    eval ${run}

    # Generate argument checking
    if [[ 0 < ${#CMDLINE_ARGUMENTS[@]} ]]; then

        # TODO: Now '+|*' must be placed last, do away this restriction

        # First check that multiple option strings don't contain "+" or "*"
        # TODO: refactor as function named __check_arg_options()
        local mul_count=0
        for ((i=2; i<${#CMDLINE_ARGUMENTS[@]}; i=i+3)); do
            local options="${CMDLINE_ARGUMENTS[i]}"
            [[ ${options} =~ \+|\* ]] && ((mul_count++))
        done
        if ((mul_count>1)); then
            Eecho "Process_cmdline: Error: Only one argument can be variable count."
            return 1
        fi

        local run=''
        for ((i=0; i<${#CMDLINE_ARGUMENTS[@]}; i=i+3)); do

            # Option string parsing
            local options="${CMDLINE_ARGUMENTS[i+2]}"
            if [[ "${options}" && "${options}" != "1" ]]; then
                if [[ ${options} =~ ^[0-9]+$ ]]; then
                    # Specific number of arguments
                    run="${run}
                    local _op_count=${options};
                    [[ \"\$1\" ]] ||
                        { Eecho 'Process_cmdline: Error: No \"${CMDLINE_ARGUMENTS[i]}\" given.'; return 1; };
                    ${CMDLINE_ARGUMENTS[i]}+=(\"\${1}\"); shift;
                    while ((_op_count > 1)); do
                        [[ \"\$1\" ]] ||
                            { Eecho 'Process_cmdline: Error: Not enough \"${CMDLINE_ARGUMENTS[i]}\" given.'; return 1; };
                        ${CMDLINE_ARGUMENTS[i]}+=(\"\${1}\"); shift;
                        ((_op_count--));
                    done;
                    "
                elif [[ ${options} == '+' ]]; then
                    # 1 or more arguments
                    # XXX: For now just read arguments greedily
                    # Eval content >>>
                    run="${run}
                    [[ \"\$1\" ]] ||
                        { Eecho 'Process_cmdline: Error: No \"${CMDLINE_ARGUMENTS[i]}\" given.'; return 1; };
                    ${CMDLINE_ARGUMENTS[i]}+=(\"\${1}\"); shift;
                    while [[ \"\$1\" ]]; do
                        ${CMDLINE_ARGUMENTS[i]}+=(\"\${1}\"); shift;
                    done;
                    "
                    # <<< Eval content
                elif [[ ${options} == '*' ]]; then
                    # 0 or more arguments
                    # XXX: For now just read arguments greedily
                    # Eval content >>>
                    run="${run}
                    while [[ \"\$1\" ]]; do
                        ${CMDLINE_ARGUMENTS[i]}+=(\"\${1}\"); shift;
                    done;
                    "
                    # <<< Eval content
                elif [[ ${options} == '?' ]]; then
                    # 0 or 1 argument
                    # Eval content >>>
                    run="${run}
                    if [[ \"\$1\" ]]; then
                        ${CMDLINE_ARGUMENTS[i]}=\"\${1}\"; shift;
                    fi;
                    "
                    # <<< Eval content
                else
                    Eecho "Process_cmdline: Warning: unknown option string '${options}'."
                    return 1
                fi

            else
                # Eval content >>>
                run="${run}
                [[ \"\$1\" ]] ||
                    { Eecho 'Process_cmdline: Error: No \"${CMDLINE_ARGUMENTS[i]}\" given.'; return 1; };
                ${CMDLINE_ARGUMENTS[i]}=\"\$1\"; shift;
                "
                # <<< Eval content
            fi
        done
        #echo "${run}" # For debug
        eval ${run}
    fi

    if [[ "$@" ]]; then
        Eecho "Process_cmdline: Error: Unkown argument(s) given: $@"
        return 1
    fi

    return 0
}
